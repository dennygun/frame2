<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>80th Independence Camera</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
  }
  #container {
    position: relative;
    width: 100vw;
    height: 100vh;
  }
  canvas, video {
    position: absolute;
    top: 0;
    left: 0;
  }
  #drawCanvas {
    pointer-events: none; /* Let touches go through */
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
</head>
<body>
<div id="container">
  <video id="webcam" autoplay playsinline muted></video>
  <canvas id="videoCanvas"></canvas>
  <canvas id="drawCanvas"></canvas>
</div>

<script>
const video = document.getElementById('webcam');
const videoCanvas = document.getElementById('videoCanvas');
const drawCanvas = document.getElementById('drawCanvas');
const videoCtx = videoCanvas.getContext('2d');
const drawCtx = drawCanvas.getContext('2d');

let model;
let drawing = false;
let lastX, lastY;

async function initCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  video.srcObject = stream;
  return new Promise(resolve => {
    video.onloadedmetadata = () => {
      video.play();
      videoCanvas.width = video.videoWidth;
      videoCanvas.height = video.videoHeight;
      drawCanvas.width = video.videoWidth;
      drawCanvas.height = video.videoHeight;
      resolve();
    };
  });
}

async function initModel() {
  model = await handPoseDetection.createDetector(handPoseDetection.SupportedModels.MediaPipeHands, {
    runtime: 'mediapipe',
    modelType: 'lite',
    maxHands: 1,
    solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands'
  });
}

function drawFrame() {
  const w = drawCanvas.width;
  const h = drawCanvas.height;

  drawCtx.save();
  drawCtx.lineWidth = 20;
  drawCtx.strokeStyle = 'red';
  drawCtx.strokeRect(0, 0, w, h);

  drawCtx.lineWidth = 15;
  drawCtx.strokeStyle = 'white';
  drawCtx.strokeRect(30, 30, w - 60, h - 60);

  drawCtx.font = '40px sans-serif';
  drawCtx.fillStyle = 'white';
  drawCtx.textAlign = 'center';
  drawCtx.fillText('80th Anniversary Indonesia Independence', w / 2, 60);
  drawCtx.restore();
}

async function renderLoop() {
  videoCtx.drawImage(video, 0, 0, videoCanvas.width, videoCanvas.height);

  const hands = await model.estimateHands(video);
  if (hands.length > 0) {
    const keypoints = hands[0].keypoints;
    const indexTip = keypoints.find(k => k.name === 'index_finger_tip');
    const thumbTip = keypoints.find(k => k.name === 'thumb_tip');

    if (indexTip && thumbTip) {
      const dist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
      if (dist < 40) {
        if (!drawing) {
          drawing = true;
          lastX = indexTip.x;
          lastY = indexTip.y;
        }
        drawCtx.beginPath();
        drawCtx.moveTo(lastX, lastY);
        drawCtx.lineTo(indexTip.x, indexTip.y);
        drawCtx.strokeStyle = 'yellow';
        drawCtx.lineWidth = 5;
        drawCtx.stroke();
        lastX = indexTip.x;
        lastY = indexTip.y;
      } else {
        drawing = false;
      }

      // Draw fingertip dot
      drawCtx.beginPath();
      drawCtx.arc(indexTip.x, indexTip.y, 8, 0, Math.PI * 2);
      drawCtx.fillStyle = 'yellow';
      drawCtx.fill();
    }
  }

  requestAnimationFrame(renderLoop);
}

(async () => {
  await initCamera();
  await initModel();
  drawFrame();
  renderLoop();
})();
</script>
</body>
</html>
