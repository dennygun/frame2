<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Minimalist Camera, Hand Draw, 80th Anniversary Indonesia Independence</title>
  <style>
    :root {
      --red: #d40000;
      --white: #ffffff;
      --bg: #0b0b0b;
      --text: #f5f5f5;
      --muted: #9aa3ab;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; }
    .app { display: grid; place-items: center; min-height: 100%; padding: 16px; }
    .cam-wrap { position: relative; width: min(92vw, 900px); aspect-ratio: 3 / 4; border-radius: 20px; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,.45); background: #000; }
    video, canvas { position: absolute; inset: 0; width: 100%; height: 100%; }
    video { object-fit: cover; /* Mirroring is now controlled by JS */ }
    .frame { pointer-events: none; position: absolute; inset: 0; box-shadow: 0 0 0 10px var(--white) inset, 0 0 0 22px var(--red) inset; border-radius: 20px; }
    .ribbon { position: absolute; top: 14px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,.92); color: #b10000; padding: 6px 14px; border-radius: 999px; font-weight: 700; font-size: clamp(12px, 2.5vw, 18px); letter-spacing: .3px; text-align: center; }
    .hud { position: absolute; bottom: 14px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; background: rgba(0,0,0,.55); border: 1px solid rgba(255,255,255,.15); padding: 10px 12px; border-radius: 999px; backdrop-filter: blur(6px); }
    .btn { appearance: none; border: 1px solid rgba(255,255,255,.2); background: rgba(255,255,255,.08); color: var(--text); padding: 8px 12px; border-radius: 12px; cursor: pointer; font-weight: 600; font-size: 14px; }
    .btn:active { transform: translateY(1px); }
    .legend { position: absolute; bottom: 70px; left: 50%; transform: translateX(-50%); color: var(--muted); font-size: 12px; text-align: center; padding: 6px 10px; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.12); border-radius: 10px; }
    .notice { margin-top: 12px; color: var(--muted); font-size: 13px; text-align: center; max-width: 900px; }
  </style>
</head>
<body>
  <div class="app">
    <div class="cam-wrap" id="cam">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="overlay"></canvas>
      <canvas id="draw"></canvas>
      <div class="frame"></div>
      <div class="ribbon">80th Anniversary Indonesia Independence</div>
      <div class="legend" id="legend">Pinch index and middle finger to draw</div>
      <div class="hud">
        <button class="btn" id="clearBtn" title="Clear drawing">Clear</button>
        <button class="btn" id="mirrorBtn" title="Toggle mirror">Mirror On</button>
        <button class="btn" id="saveBtn" title="Save snapshot">Save</button>
      </div>
    </div>
    <div class="notice" id="status">Requesting camera permission...</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <script>
    const videoEl = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const draw = document.getElementById('draw');
    const clearBtn = document.getElementById('clearBtn');
    const mirrorBtn = document.getElementById('mirrorBtn');
    const saveBtn = document.getElementById('saveBtn');
    const statusEl = document.getElementById('status');
    const legendEl = document.getElementById('legend');

    let isMirrored = true;

    function setMirror(mirrored) {
      isMirrored = mirrored;
      const transform = isMirrored ? 'scaleX(-1)' : 'none';
      videoEl.style.transform = transform;
      draw.style.transform = transform;
      overlay.style.transform = transform;
    }

    function fitCanvases() {
      const rect = document.getElementById('cam').getBoundingClientRect();
      [overlay, draw].forEach(c => { c.width = rect.width; c.height = rect.height; });
    }
    addEventListener('resize', fitCanvases);

    const octx = overlay.getContext('2d');
    const dctx = draw.getContext('2d');
    dctx.lineCap = 'round';
    dctx.lineJoin = 'round';
    dctx.lineWidth = 8;
    dctx.strokeStyle = '#ffffff';

    const colors = ['#ffffff', '#d40000'];
    let colorIndex = 0;

    function cycleColor() {
      colorIndex = (colorIndex + 1) % colors.length;
      dctx.strokeStyle = colors[colorIndex];
    }

    let drawing = false;
    let lastPt = null;

    function getGestureInfo(landmarks, w, h) {
      const a = landmarks[8]; // Index finger tip
      const b = landmarks[12]; // Middle finger tip
      const x1 = a.x * w, y1 = a.y * h;
      const x2 = b.x * w, y2 = b.y * h;
      const dx = x2 - x1, dy = y2 - y1;
      const dist = Math.hypot(dx, dy);
      const x = (x1 + x2) / 2;
      const y = (y1 + y2) / 2;
      return { dist, x, y };
    }

    let hintTimer = setTimeout(() => legendEl.style.opacity = .0, 6000);

    function onResults(results) {
      fitCanvases();
      octx.clearRect(0, 0, overlay.width, overlay.height);

      if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
        drawing = false;
        lastPt = null;
        return;
      }
      
      const landmarks = results.multiHandLandmarks[0];

      // **FIX 1: Draw landmarks directly on the transparent overlay**
      // The overlay canvas is now mirrored with CSS, so landmarks align correctly.
      octx.globalAlpha = .6;
      window.drawConnectors(octx, landmarks, window.HAND_CONNECTIONS, { color: 'rgba(255,255,255,.35)', lineWidth: 1 });
      window.drawLandmarks(octx, landmarks, { color: 'rgba(255,255,255,.7)', lineWidth: 1, radius: 1.5 });

      // **FIX 2: Simplified drawing logic**
      // Coordinates from MediaPipe are used directly. CSS handles the visual mirroring.
      const { dist, x, y } = getGestureInfo(landmarks, overlay.width, overlay.height);
      const pinchThreshold = Math.max(20, overlay.width * 0.03);

      if (dist < pinchThreshold) {
        const pt = { x, y };
        if (!drawing) {
          drawing = true;
          lastPt = pt;
          cycleColor();
        } else {
          dctx.beginPath();
          dctx.moveTo(lastPt.x, lastPt.y);
          const mx = lastPt.x + (pt.x - lastPt.x) * 0.8;
          const my = lastPt.y + (pt.y - lastPt.y) * 0.8;
          dctx.lineTo(mx, my);
          dctx.stroke();
          lastPt = { x: mx, y: my };
        }
      } else {
        drawing = false;
        lastPt = null;
      }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    hands.onResults(onResults);

    async function start() {
      try {
        statusEl.textContent = 'Starting camera...';
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
        videoEl.srcObject = stream;
        // Wait for the video to be ready
        videoEl.onloadedmetadata = () => {
          videoEl.play();
          fitCanvases();
          setMirror(true); // Start mirrored by default

          const camera = new Camera(videoEl, {
            onFrame: async () => await hands.send({image: videoEl}),
            width: videoEl.videoWidth, height: videoEl.videoHeight
          });
          camera.start();
          statusEl.textContent = 'Pinch index and middle finger to draw.';
        };
      } catch (e) {
        console.error(e);
        statusEl.textContent = 'Camera access failed. Check permissions and reload.';
      }
    }

    clearBtn.addEventListener('click', () => dctx.clearRect(0, 0, draw.width, draw.height));

    mirrorBtn.addEventListener('click', () => {
      setMirror(!isMirrored);
      mirrorBtn.textContent = isMirrored ? 'Mirror On' : 'Mirror Off';
    });

    // **FIX 3: Updated save logic**
    saveBtn.addEventListener('click', () => {
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = overlay.width;
      exportCanvas.height = overlay.height;
      const ectx = exportCanvas.getContext('2d');

      // 1. Draw the video, mirrored if necessary
      ectx.save();
      if(isMirrored) {
          ectx.translate(exportCanvas.width, 0);
          ectx.scale(-1, 1);
      }
      ectx.drawImage(videoEl, 0, 0, exportCanvas.width, exportCanvas.height);
      ectx.restore();
      
      // 2. Draw the user's drawing on top
      ectx.drawImage(draw, 0, 0);

      // 3. Draw the frame and ribbon
      const insetWhite = 10, insetRed = 22;
      ectx.save();
      ectx.strokeStyle = '#ffffff';
      ectx.lineWidth = insetWhite * 2;
      roundRect(ectx, insetWhite, insetWhite, exportCanvas.width - insetWhite * 2, exportCanvas.height - insetWhite * 2, 20);
      ectx.stroke();
      ectx.strokeStyle = '#d40000';
      ectx.lineWidth = (insetRed - insetWhite) * 2;
      roundRect(ectx, insetRed, insetRed, exportCanvas.width - insetRed * 2, exportCanvas.height - insetRed * 2, 20);
      ectx.stroke();

      const text = '80th Anniversary Indonesia Independence';
      ectx.font = `${Math.max(14, Math.round(exportCanvas.width * 0.022))}px ui-sans-serif, system-ui, -apple-system`;
      const tw = ectx.measureText(text).width;
      const tx = exportCanvas.width / 2 - tw / 2;
      const rbX = tx - 16, rbY = 14, rbW = tw + 32, rbH = parseInt(ectx.font, 10) + 12;
      ectx.fillStyle = 'rgba(255,255,255,.92)';
      roundRect(ectx, rbX, rbY, rbW, rbH, rbH / 2);
      ectx.fill();
      ectx.fillStyle = '#b10000';
      ectx.textBaseline = 'middle';
      ectx.fillText(text, tx, rbY + rbH / 2);
      ectx.restore();

      const a = document.createElement('a');
      a.href = exportCanvas.toDataURL('image/png');
      a.download = 'air-drawing-indonesia-80th.png';
      a.click();
    });

    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    start();
  </script>
</body>
</html>